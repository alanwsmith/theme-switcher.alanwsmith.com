<!doctype html>
<html lang="en">
  <head>
    [! include "_wrappers/_head.html" !]
    [! include "styles/_main.html" !]

<style>

:root {
  --load-hider: 0;
}

.load-hider {
  opacity: var(--load-hider);
}

[data-receive=themeSwitcher] {
  display: flex;
  gap: 1rem;
}

  [! include "_includes/styles/0010-colors.css" !]
  [! include "_includes/styles/0020-light-mode.css" !]
  [! include "_includes/styles/0030-dark-mode.css" !]
  [! include "_includes/styles/0040-body.css" !]
</style>
    
    [! include "_includes/theme-loader.html" !]
  </head>
  <body>
      [! include "_wrappers/_noscript.html" !]

    <bitty-5-1 
      data-connect="/scripts/theme-switcher.js"
      data-send="themeSwitcher"
      class="load-hider"
      >

      <header class="default-wrapper xlarge-bottom-margin default-flow">
        <div class="small-font">
          from <a href="https://www.alanwsmith.com/">alan w smith</a> ~
          [@- ' ' -@]
          [!- if json.data._config.site.github_url -!]
            <a href="[@ json.data._config.site.github_url @]">source</a> ~
          [!- endif -!]
          [@- ' ' -@]
          <a href="https://socials.alanwsmith.com/">socials</a> ~
          <a href="https://links.alanwsmith.com/">other projects</a> ~
          <a href="https://www.alanwsmith.com/feeds/posts.xml">rss</a>
        </div>
        <div data-location="top" data-receive="themeSwitcher" class="small-font"></div>
      </header>

      <main class="default-wrapper">
        <hgroup>
          <h1>Page Theme Switcher</h1>
        </hgroup>
        
        <p>
          This is how I'm doing my color mode/theme/scheme switcher.
        </p>

        <h2>Live Example</h2>
        <div data-location="middle" data-receive="themeSwitcher"></div>

        <h2>Overview</h2>
        <p>The process I'm using breaks down like this:</p>
        <ol>
          <li>Create individual CSS Custom Property/Variables for each theme. I'm using three ('light', 'dark', and 'high-contrast'), but you can make as many as you'd like.</li>
          <li>Create light and dark mode variables that point to the individual variables for each theme. (Nothing is done with 'high-contrast' at this stage as it's only set by JavaScript). </li>
          <li>Create element styles that call `*--switch` variables that don't initially exist 
            with fallbacks to the mode specific variables.</li>
          <li>Add a script tag to the head of the document that uses 
            JavaScript (if it's available) to populate the `*--switch` variables
            based of user selections on the page.</li>
        </ol>

        <p>
          The result is a progressively enhanced theme
          setup. JavaScript is used to set the theme
          if everything is functional. Values fall
          back to the `prefers-color-scheme` if JavaScript
          is either unavailable or if no manual 
          preference has been set. If the 
          `prefers-color-scheme` value isn't found
          the styles fall back to the non-customized
          version. 
        </p>

        <h2>Details</h2>

        <h3>The CSS</h3>
        <p>My style sheet breaks down into four sections:</p>

        <ol>
          <li>
            <p>The base color variables for each theme</p>
            <pre class="code-block">[!- filter highlight_css|safe -!]
              [!- include "_includes/styles/0010-colors.css" -!]
              [!- endfilter -!]</pre>
          </li>
          <li>
            <p>
              Default variables set to use the primary `--light-*``
              variables</p>
            <pre class="code-block">[!- filter highlight_css|safe -!]
              [!- include "_includes/styles/0020-light-mode.css" -!]
              [!- endfilter -!]</pre>
          </li>
          <li>
            <p>
              Dark mode variables set to use the primary `--dark-*``
              variables</p>
            <pre class="code-block">[!- filter highlight_css|safe -!]
              [!- include "_includes/styles/0030-dark-mode.css" -!]
              [!- endfilter -!]</pre>
          </li>
          <li>
            <p>Page element styles that set to use `*--switch` variables
              (that don't exist yet) with fallbacks to the 
              basic variable names. </p>
            <pre class="code-block">[!- filter highlight_css|safe -!]
              [!- include "_includes/styles/0040-body.css" -!]
              [!- endfilter -!]</pre>
          </li>
        </ol>

        <h3>The JavaScript </h3>
        <p>
          This script tag goes directly in the &lt;head&gt; of the
          page directly after the call for the stylesheet. 
        </p>
          <pre class="code-block">[!- filter highlight_html|safe -!]
            [!- include "_includes/theme-loader.html" -!]
            [!- endfilter -!]</pre>

        <p>
          The first thing the script does is make the <code>updateStyles()</code>
          function. The <code>styleKeys</code> array inside it
          defines the list of styles to update based off the
          naming the naming convention that maps the base
          colors to the <code>*--switch</code> versions. 
        </p>
        <p>
          The function checks to make sure a theme 
          value is passed then uses it to determine what
          happens next. 
          It it's <code>auto</code>,
          the function removes the custom <code>*--switch</code> properties. 
          Otherwise, it adds them with the given theme name. 
        </p>
        <p>
          After the properties, the function
          also updates the localStorage value
          with the theme. 
          Doing that means
          all the storage checking and setting
          happens in the same place. No need
          to mess with it in whatever scripting
          is used for the interface. 
        </p>
        <p>
          After the function is set up, the 
          script makes an initial call to it
          with the current localStorage 
          value for `theme`.
        </p>


        <h3>The Interface</h3>
        <p>
          The last step is making an interface on the page.
          I'm using <a href="https://bitty.alanwsmith.com/">bitty</a>.
          Other approaches would work just as well. The 
          only real requirement is calling the
          <code>updateStyles()</code> function with
          the name of the theme. 
        </p>

        <details class="default-flow"><summary>bitty approach</summary>
        <p>
          Since the theme switcher doesn't work
          without JavaScript. So, I use this
          empty HTML element that gets populated
          directly by it. That way, the HTML
          radio buttons don't show up on the page
            if the JavaScript fails for some reason.
          </p>

            <pre class="code-block">[!- filter highlight_html|safe -!]
<div data-location="area-name" data-receive="themeSwitcher"></div>
              [!- endfilter -!]</pre>

        <p>
          And then this in the `/scripts/theme-switcher.js` file:
        </p>

            <pre class="code-block">[!- filter highlight_javascript|safe -!]
              [!- include "scripts/theme-switcher.js" -!]
              [!- endfilter -!]</pre>

        </details>

        <h2>Full Example</h2>
        <p>
          Here's a full HTML page to show how
          everything looks when combined that
          you can <a href="/full-example/">check out here</a>.
        </p>

      <pre class="code-block">[!- filter highlight_html|safe -!]
        [!- include "full-example/index.html" -!]
        [!- endfilter -!]</pre>

        <p>
          The `/styles/example-styles.css` file looks like
          this:</p>

      <pre class="code-block">[!- filter highlight_css|safe -!]
        [!- include "styles/example-styles.css" -!]
        [!- endfilter -!]</pre>


      <h2>Endnotes</h2>
        <ul>
          <li>
            Some folks have Strong Opinions about putting 
            inline script tags on pages. I like
            the approach here because it helps ensure
            there's no flash between colors when
            a color is found/set on the JavaScript
            side. 
          </li>


          <li>
            I'm intentionally avoiding a <code>noscript</code>
            tag for the color theme switcher. 
            It's not critical for the content or
            for the page to function. 
          </li>

          <li>
            This approach requires explicitly listing
            all the keys for the styles you want
            to change (e.g. `background`, `color`,
            `link`). Another approach would be 
            to loop through all the properties
            and do a find/replace style update. 
            That <a href="https://tylergaw.com/blog/how-to-get-all-custom-properties-on-a-page-in-javascript/">
              ends up being a lot more code</a>.
            I may switch to that at some point,
            but I don't have that many updates
            to my site where I need to 
            adjust what styles are getting updated. 
          </li>

          <li>
            I'm not doing anything with `color-scheme: light dark;`
            in this example. I still need to dig
            into it to figure out how to make
            it reactive to JavaScript when
            that's what sets the theme. (e.g. 
            switching to the `light` version 
            when JavaScript sets the theme 
            to `light`, but the value coming
            in from `prefers-color-scheme` is `dark`.
          </li>

          <li>
            I'm not doing anything to update different
            windows if you have multiple pages
            open when you change themes. That's entirely
            possible, but not worth the complexity 
            for the sites I generally build.
          </li>

          <li>
            The bitty code includes a `load-hider` that
            sets the opacity of the main element to 
            zero until it's finished loading. That's
            not strictly necessary for the theme switcher.
            However, it does prevent the page from 
            jumping around visually as the theme switcher
            buttons are populated. (noscript and JavaScript
            setTimeout fallbacks are included to
            cover times when the main script doesn't
            load or JavaScript isn't available.)
          </li>

          <li>
            The interface I'm building on these
            pages with bitty provides the ability
            to have multiple instances of the
            switcher on the page and keep them
            all in sync. That's not necessary,
            but I like having the feature.
          </li>
          
          <li>
            bitty is a web component that makes pages
            interactive. You can
            <a href="https://bitty.alanwsmith.com/">go here to learn more about it</a>.
          </li>

        </ul>

      </main>

      [! include "_wrappers/_footer.html" !]

    </bitty-5-1>

    <script src="/components/bitty-5.1.0.min.js"></script>
    <script>
      setTimeout(() => {
        document.documentElement.style.setProperty("--load-hider", "1");
      }, 1300);
    </script>
  </body>
</html>
